/* 
  Anelosimus.Eximius.pgc : This process gets a list of URLs from 
  the table "node", downloads them, inserts the new URLs into table node,
  and new links into table "links".

    Copyright (C) 2011  Pierre Jourlin

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
***********************************************************************************
  Anelosimus.Eximius.pgc : Ce processus récupère une liste d'URLs dans
  la table "node", les télécharge, insère dans la même table les nouvelles
  URLs découvertes et dans la table "links", les nouveaux liens.

  Copyright (C) 2011 Pierre Jourlin — Tous droits réservés.
 
  Ce programme est un logiciel libre ; vous pouvez le redistribuer ou le
  modifier suivant les termes de la “GNU General Public License” telle que
  publiée par la Free Software Foundation : soit la version 3 de cette
  licence, soit (à votre gré) toute version ultérieure.
  
  Ce programme est distribué dans l’espoir qu’il vous sera utile, mais SANS
  AUCUNE GARANTIE : sans même la garantie implicite de COMMERCIALISABILITÉ
  ni d’ADÉQUATION À UN OBJECTIF PARTICULIER. Consultez la Licence Générale
  Publique GNU pour plus de détails.
  
  Vous devriez avoir reçu une copie de la Licence Générale Publique GNU avec
  ce programme ; si ce n’est pas le cas, consultez :
  <http://www.gnu.org/licenses/>.

    Pierre Jourlin
    L.I.A. / C.E.R.I.
    339, chemin des Meinajariès
    BP 1228 Agroparc
    84911 AVIGNON CEDEX 9
    France 
    pierre.jourlin@univ-avignon.fr
    Tel : +33 4 90 84 35 32
    Fax : +33 4 90 84 35 01

*/

#include <stdlib.h>
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <curl/multi.h>
#include <sys/types.h> 
#include <signal.h>

#define MAXURLSIZE		(100*1024) /* 100 Kb */
#define MAXCO			10	// Max parrallel connections
#define MAXSMALLSTRING		512	// Max number of chars in top level domain

exec sql include sqlca;
exec sql begin declare section;
	struct MemoryStruct {
		char *memory;
		unsigned long int size;
	};
exec sql end declare section;
exec sql begin declare section;
	unsigned long int MaxPageSize=0;
	int nurls;
	struct MemoryStruct currentBody[MAXCO];
	char currentURL[MAXURLSIZE];
	char url_chunk[MAXCO][MAXURLSIZE];
	unsigned long int url_id[MAXCO];
	char url_enc[MAXCO][MAXSMALLSTRING];
	char LinkMidContext[MAXURLSIZE];
	char currentRoot[MAXURLSIZE];
	char currentRootURL[MAXURLSIZE];
	char currentEffectiveURL[MAXURLSIZE];
	char currentEncoding[MAXSMALLSTRING];
	unsigned long int currentID;
exec sql end declare section;
EXEC SQL BEGIN DECLARE SECTION;
const char *target = "webcrawler@localhost:5433"; // Data for connection if needed
const char *user = "hypolite";
const char *password ="*****";
const char *port="5433";

EXEC SQL END DECLARE SECTION;

void terminate(int sig);

void checkErrorCode(void){
	if(sqlca.sqlcode!=0){
		if(sqlca.sqlcode!=-403){
    			fprintf(stderr,"error code %ld, message [%s], rows %ld, warning %c\n", 
    			sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrd[2], 
    			sqlca.sqlwarn[0]);
			if(currentRoot!=NULL)
				fprintf(stderr, "While Processing %s with enc=%s\n", currentRoot, currentEncoding);
		}
		else {
			// not necessarily wrong : might already got this info
		}
	}
}


size_t curl_write( void *ptr, size_t size, size_t nmemb, void *userdata)
{	
	struct MemoryStruct *mem= &currentBody[(long int) userdata];
	mem->memory=realloc(mem->memory, ((size_t) mem->size+1) + size*nmemb); // extend memory
	
	if(mem->memory==NULL){
   		 /* out of memory! */ 
    		printf("not enough memory (realloc returned NULL)\n");
    		exit(EXIT_FAILURE);
  	}
	memcpy(&(mem->memory[mem->size]), ptr, size*nmemb);
	mem->size+=(unsigned long int) (size*nmemb);
	mem->memory[mem->size] = 0;
	return size*nmemb;
}

int getNextURL(bool reinit, int idx){
	static const char *tag="href=\"";
	static char *start;
	*LinkMidContext='\0';

	if(reinit){
		start=currentBody[idx].memory;
		return TRUE;
	}
	char *end=start;
	char *startmid, *endmid;

	start=strstr(start, tag);
	
	if(start!=NULL){
		start+=strlen(tag);
		end=strstr(start, "\"");
		if(end!=NULL){
			if((end-start) <MAXURLSIZE){
				memcpy(currentURL, start, (size_t) (end-start));
				*(currentURL+(size_t) (end-start))='\0';
				//printf("Current URL: %s\n", currentURL);
				startmid=strstr(start, ">");
				if((startmid!=NULL) && (*(startmid-1)!='/'))
					endmid=strstr(startmid, "<");
				else
					endmid=startmid+1;
				if(startmid==NULL||endmid==NULL||(endmid-startmid)>=MAXURLSIZE||endmid==(startmid+1))
					*LinkMidContext='\0';
				else{
					memcpy(LinkMidContext, startmid+1, (size_t) (endmid-startmid)-1);
					*(LinkMidContext+(size_t) (endmid-startmid)-1)='\0';
					//printf("Mid : {%s}\n",LinkMidContext); 
				}
		
			}
			else
				end=NULL;
		}
		start=end;
	}
	return (start!=NULL);
}

static void init(CURLM *cm, int i, unsigned long header)
{
  CURL *eh = curl_easy_init();
  
  curl_easy_setopt(eh, CURLOPT_URL, url_chunk[i]);
  curl_easy_setopt(eh, CURLOPT_FOLLOWLOCATION, 1);
  curl_easy_setopt(eh, CURLOPT_MAXREDIRS, -1);
  curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, curl_write);
  curl_easy_setopt(eh, CURLOPT_WRITEDATA, (void *) (long int) i);
  curl_easy_setopt(eh, CURLOPT_HEADER, header);
  curl_easy_setopt(eh, CURLOPT_NOBODY, header);
  curl_easy_setopt(eh, CURLOPT_TIMEOUT, 1L); 
  curl_easy_setopt(eh, CURLOPT_PRIVATE, i);
  curl_easy_setopt(eh, CURLOPT_VERBOSE, 0L);
  curl_easy_setopt(eh, CURLOPT_DNS_CACHE_TIMEOUT, 48*60*60); // 48h 
  curl_multi_add_handle(cm, eh);
}



void terminate(int sig) {
	exec sql UPDATE node SET checked=NULL, effectiveurl=NULL WHERE url=:currentRootURL;
	exec sql disconnect all;
        printf("\nInterrupted ! Cancelling the crawl on %s\n", currentRootURL);
	curl_global_cleanup();
        exit(sig);
}

void xhtml2text(char *mem){
	char *pt=mem;
	while(*pt!=0){				// parse until the end of string
		while(*pt!=0 && *pt!='<')	// copy text when outside a tag
			*mem++=*pt++;
		while(*pt!=0 && *pt!='>')	// ignore text when inside a tag
			pt++;
		if(*pt){
			*mem++='\n';
			pt++;
		}
	};
	*mem=0;					// terminate the new, shortened string
}

void drop_blanks(char *mem){
	char *pt=mem;
	while(*pt!=0){				// parse until the end of string
		while(*pt!=0 && *pt!=' ' && *pt!='\t' && *pt !='\r' && *pt!='\n')	// copy text
			*mem++=*pt++;
		while(*pt!=0 && (*pt==' '||*pt=='\t'||*pt=='\r'||*pt=='\n'))	// ignore blanks
			pt++;
		if(*pt)
			*mem++=' ';
	};
	*mem=0;					// terminate the new, shortened string
}

void drop_content(char *mem, const char *tstart, const char *tend){
	char *start, *end;

	start=strstr(mem, tstart);
	do{
		if(start==NULL)	// Done
			return;
		else
			end=strstr(start, tend);
		if(end==NULL)
			*start=0;	// remove all the text starting with <script 
		else
			strcpy(start, end+strlen(tend));	// remove the text between script tags
		start=strstr(start, tstart);
	}while(1);
}

int main(void) {
	CURL *curl;
	CURLcode res;
	char *tmp;

	CURLM *cm;
  	CURLMsg *msg;
  	long nburls, L;
  	unsigned int C=0;
  	int M, Q, U;
  	fd_set R, W, E;
  	struct timeval T;

	pid_t pid;
	if ((pid = getpid()) < 0) {
	  perror("unable to get pid");
	};
	

	(void) signal(SIGINT,terminate);

// 	uncomment the following line if you need database details for the connection
	exec sql connect to :target USER :user USING :password;
// 	if no details are needed, simply do :
//	exec sql connect to 'unix:postgresql:locahost' ;
	checkErrorCode();
//	exec sql SET CLIENT_ENCODING TO 'UTF8'; 
	while(1){
		M=Q=U=-1; // re-init error flags
		EXEC SQL BEGIN WORK;
		EXEC SQL PREPARE get_url FROM "SELECT url_out(url) as url, id FROM node WHERE checked IS NULL AND score IS NOT NULL ORDER BY score DESC LIMIT 10 FOR UPDATE ;";
		checkErrorCode();
		EXEC SQL COMMIT WORK;
		EXEC SQL BEGIN WORK;
		EXEC SQL DECLARE url_cursor CURSOR FOR get_url;
		checkErrorCode();
		/* when end of result set reached, break out of while loop */
		EXEC SQL WHENEVER NOT FOUND DO BREAK;
		checkErrorCode();
		EXEC SQL OPEN url_cursor;

		checkErrorCode();
		nburls=0;
		while(1){
			EXEC SQL FETCH NEXT FROM url_cursor INTO :currentRootURL, :currentID;
			//printf("[%d] is processing %s\n", pid, currentRootURL );
			checkErrorCode();
			if(sqlca.sqlcode!=0)
				return;
			exec sql UPDATE node SET checked=now() WHERE id=:currentID;
	                checkErrorCode();
	                if(sqlca.sqlcode!=0)
	                        return;
			strcpy(url_chunk[nburls], currentRootURL);
			url_id[nburls]=currentID;
			nburls++;
		}
		EXEC SQL CLOSE url_cursor;
		EXEC SQL COMMIT WORK;
		curl_global_init(CURL_GLOBAL_ALL);
		cm = curl_multi_init();
		for (C = 0; C < nburls; ++C) {
    			init(cm, C, 1);			/* Only headers at the moment */
			getNextURL(TRUE, C); 		// initialize
			currentBody[C].memory=malloc(1); // For the null char
			currentBody[C].size=0;	// no char at this point  

  		}
		nburls=0; // reused for counting html and xml urls
		while (U) {
			curl_multi_perform(cm, &U);
	 		if (U) {
 				FD_ZERO(&R);
				FD_ZERO(&W);
				FD_ZERO(&E);
 
				if (curl_multi_fdset(cm, &R, &W, &E, &M)) {
					fprintf(stderr, "E: curl_multi_fdset\n");
					return EXIT_FAILURE;
				}
 
				if (curl_multi_timeout(cm, &L)) {
					fprintf(stderr, "E: curl_multi_timeout\n");
					return EXIT_FAILURE;
				}
				if (L == -1)
					L = 100;
	 
				if (M == -1) {
					#ifdef WIN32
					Sleep(L);
					#else
					sleep(L / 1000);
					#endif
				} else {
					T.tv_sec = L/1000;
					T.tv_usec = (L%1000)*1000;
 					if (0 > select(M+1, &R, &W, &E, &T)) {
						fprintf(stderr, "E: select(%i,,,,%li): %i: %s\n", M+1, L, errno, strerror(errno));
        	  				return EXIT_FAILURE;
        				}
      				}
			}
 			while ((msg = curl_multi_info_read(cm, &Q))) {
				if (msg->msg == CURLMSG_DONE) {
					char *url, *eurl, *ct;
					CURL *e = msg->easy_handle;
					curl_easy_getinfo(msg->easy_handle, CURLINFO_PRIVATE, &nburls);
					curl_easy_getinfo(msg->easy_handle, CURLINFO_EFFECTIVE_URL, &eurl);
					curl_easy_getinfo(msg->easy_handle, CURLINFO_CONTENT_TYPE, &ct);
					strcpy(url_enc[nburls],"LATIN1"); // Default Charset

					if( (ct!=NULL) && 
							(	(strstr(ct, "text/html")!=NULL) 
								|| (strstr(ct, "text/xml")!=NULL)
							)
						){
						// fprintf(stderr,"CT:[%s]\n", ct);
						if(nburls<0 || nburls>=MAXCO){
							printf("Ooops ! : nburls=%ld\nBye...\n", nburls);
							exit(-1);
						}
						strcpy(currentEffectiveURL, eurl);
						strcpy(currentURL, url_chunk[nburls]);
						strcpy(url_chunk[nburls], eurl);
						if(strstr(ct, "utf-8")!=NULL || strstr(ct, "UTF-8")!=NULL)
							strcpy(url_enc[nburls],"UTF8");
						//printf("Warning : %ld[%s] for %s\n", nburls, url_enc[nburls], url_chunk[nburls]);
                                                exec sql BEGIN WORK;
						exec sql UPDATE node SET effectiveurl=:currentEffectiveURL WHERE url=:currentURL;
						checkErrorCode();
						exec SQL END WORK;
					}
					curl_multi_remove_handle(cm, e);
					curl_easy_cleanup(e);
				}
				else {
        				fprintf(stderr, "E: CURLMsg (%d)\n", msg->msg);
				}
				nburls++;
			}
		}
		for (C = 0; C < nburls; ++C) 
			if(currentBody[C].memory){
				free(currentBody[C].memory);
			}

		/***   Get links ****/
		M=Q=U=-1; // re-init error flags
		for (C = 0; C < nburls; ++C) {
    			init(cm, C, 0);			/* Now get Full pages */
			getNextURL(TRUE, C); // initialize
			currentBody[C].memory=malloc(1); // for the null char
			currentBody[C].size=0;	// no data at this point, only the terminal null char  
  		}

		while (U) {
			curl_multi_perform(cm, &U);
	 		if (U) {
 				FD_ZERO(&R);
				FD_ZERO(&W);
				FD_ZERO(&E);
 
				if (curl_multi_fdset(cm, &R, &W, &E, &M)) {
					fprintf(stderr, "E: curl_multi_fdset\n");
					return EXIT_FAILURE;
				}
 
				if (curl_multi_timeout(cm, &L)) {
					fprintf(stderr, "E: curl_multi_timeout\n");
					return EXIT_FAILURE;
				}
				if (L == -1)
					L = 100;
	 
				if (M == -1) {
					#ifdef WIN32
					Sleep(L);
					#else
					sleep(L / 1000);
					#endif
				} else {
					T.tv_sec = L/1000;
					T.tv_usec = (L%1000)*1000;
 					if (0 > select(M+1, &R, &W, &E, &T)) {
						fprintf(stderr, "E: select(%i,,,,%li): %i: %s\n", M+1, L, errno, strerror(errno));
        	  				return EXIT_FAILURE;
        				}
      				}
			}

 			while ((msg = curl_multi_info_read(cm, &Q))) {
				if (msg->msg == CURLMSG_DONE) {
					char *url;
					CURL *e = msg->easy_handle;
					curl_easy_getinfo(msg->easy_handle, CURLINFO_PRIVATE, &url);
					//fprintf(stderr, "R: %d - %s <%s>\n", msg->data.result, curl_easy_strerror(msg->data.result), url);
					curl_multi_remove_handle(cm, e);
					curl_easy_cleanup(e);
				}
				else {
        				fprintf(stderr, "E: CURLMsg (%d)\n", msg->msg);
				}
			}
		}
		for (C = 0; C < nburls; ++C) {
			getNextURL(TRUE, C);
			strcpy(currentURL, url_chunk[C]);
			strcpy(currentRootURL, currentURL); 
			tmp=strstr(currentRootURL,"://"); /* Extract root website URL */
			if(tmp!=NULL)
				tmp=strstr(tmp+3, "/");
			if(tmp!=NULL)
				*tmp='\0';
			strcpy(currentEncoding, url_enc[C]);
			currentID=url_id[C];
			fprintf(stderr,"Processing [%s], %d, encoding [%s]\n", currentURL, C, url_enc[C]);
			
  	 		while(getNextURL(FALSE, C)){
				exec sql BEGIN WORK;
				exec sql SET CLIENT_ENCODING TO :currentEncoding; 
				if(strlen(currentURL)>1 && (currentURL[0]=='/'||currentURL[0]=='.'||currentURL[0]=='.')){

					strcpy(currentRoot, currentRootURL);
					if(currentURL[0]!='/' || currentRoot[strlen(currentRoot)-1]!='/')
						strcat(currentRoot, currentURL);
					else 
						strcat(currentRoot, currentURL+1);
				}
				else
					strcpy(currentRoot, currentURL);
				if(strlen(currentRoot)>7 && (!strncmp(currentRoot, "http://",7) || !strncmp(currentRoot, "https://",8) || !strncmp(currentRoot, "ftp://",6) || !strncmp(currentRoot, "ftps://",7))){
					if(strlen(LinkMidContext)>0)
						exec sql INSERT INTO linksview ("from", "to", midcontext) VALUES (:currentID, :currentRoot, :LinkMidContext);
					else
						exec sql INSERT INTO linksview ("from", "to") VALUES (:currentID, :currentRoot);
					checkErrorCode();
				}
				exec SQL END WORK;
					
			}
			//printf("Done.\n");
			if(sqlca.sqlcode==0){
				if(currentBody[C].size > MaxPageSize){
					MaxPageSize=currentBody[C].size;
					// fprintf(stderr, "*** New maximum page size %ld\n", MaxPageSize);
				}
				drop_content(currentBody[C].memory, "<!--", "-->");
				drop_content(currentBody[C].memory, "<script ", "</script>");
				drop_content(currentBody[C].memory, "<style ", "</style>");
				xhtml2text(currentBody[C].memory);
				drop_blanks(currentBody[C].memory);
				exec sql BEGIN WORK;
				exec sql UPDATE node SET content=:currentBody[C].memory WHERE url=:url_chunk[C];
				checkErrorCode();
				exec SQL END WORK;
			}
			//printf("Content of %s:\n [%s]\n", url_chunk[C], currentBody[C].memory);
			if(currentBody[C].memory){
				//printf("Free2 :%d\n", C);
				free(currentBody[C].memory);
			}
  		}
		curl_multi_cleanup(cm);
		curl_global_cleanup();
		
	}
	EXEC SQL disconnect all;
	return EXIT_SUCCESS;
}

